<html>

  
<head>
<title>XTF Programming Guide</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<style type="text/css">
      <!--
        .DocTitle     { margin-left:  0.00in;
                        font-family:  Arial, Helvetica, sans-serif;
                        font-size:    180%;
                        font-style:   normal;
                        font-weight:  bold;
                        font-variant: small-caps; }

        .BaseStyle    { margin-left:  0.00in;
                        font-family:  "Times New Roman", Times, serif;
                        font-size:    100%;
                        font-style:   normal;
                        font-weight:  normal;
                        font-variant: normal; }

        .IndentL      { margin-left: 0.25in; margin-right: 0.00in }
        .IndentLR     { margin-left: 0.25in; margin-right: 0.25in }

        .Heading1     { font-size:    140%;
                        font-style:   normal;
                        font-weight:  bold;
                        font-variant: small-caps;
                        width:        100%;
                        line-height:  normal;
                        color:        #b6953b;
                        border-color: #b6953b;
                        border-style: solid;
                        border-left-width: 0px; border-right-width:  0px;
                        border-top-width:  0px; border-bottom-width: 3px;
                        margin-top: 28pt; margin-bottom: 4pt }

        .Heading2     { font-size:    120%;
                        font-style:   normal;
                        font-weight:  bold;
                        width:        100%;
                        line-height:  normal;
                        color:        #576490;
                        border-color: #576490;
                        border-style: solid;
                        border-left-width: 0px; border-right-width:  0px;
                        border-top-width:  0px; border-bottom-width: 2px;
                        margin-top: 24pt; margin-bottom: 4pt }

        .Heading3     { font-size:    100%;
                        font-style:   normal;
                        font-weight:  bold;
                        line-height:  normal;
                        color:        #000000;
                        border-color: #000000;
                        border-style: solid;
                        border-left-width: 0px; border-right-width:  0px;
                        border-top-width:  0px; border-bottom-width: 1px;
                        margin-top: 20pt; margin-bottom: 4pt }


        .Code         { font-family: "Courier New", Courier, mono;
                        font-size:   100%;
                        font-style:  normal;
                        font-weight: bold;
                        color:       #112233 }

        .MacroCode    { font-family: "Times New Roman", Times, serif;
                        font-style:  italic;
                        font-weight: bold;
                        color:       #576490 }

        .MacroCodeB   { font-family: "Times New Roman", Times, serif;
                        font-style:  italic;
                        font-weight: bold;
                        color:       #990099 }

        .Sample       { margin-left: 0.15in; margin-right: 0.1in;
                        background-color: #E0E0E0;
                        padding-top:  8px; padding-bottom: 8px;
                        padding-left: 8px; padding-right:  8px;
                        border-style: none }

        .Note         { color:      #990000;
                        font-style: italic;
                        margin-left: 0.15in; margin-right: 0.15in }

        .Red           { color: #990000; font-style: italic; }

        .GreyList     { background-color: #E0E0E0;
                        margin-left: 0.15in; margin-right: 0.15in;
                        margin-top:   5px;  margin-bottom:  0px;
                        padding-left: 8px;  padding-right:  8px;
                        padding-top:  8px;  padding-bottom: 8px }

        .ParamList    { margin-top: 5px;  margin-bottom: 0px; }

        .OrderedList   { margin-left:         0.35in;
                         list-style-position: outside;
                         list-style-image:    none;
                         list-style-type:     decimal }

        .UnorderedList { margin-left:         0.35in;
                         list-style-position: outside;
                         list-style-type:     disc }

        .NoBullets  { margin-left:     0.25in;
                      list-style-type: none }

        .ListItem  { margin-top: 6px; }
      -->
    </style>
</head>

  <body bgcolor="#FFFFFF" text="#101010" >
<div class="BaseStyle"> 
  <p class="DocTitle" align="center">Extensible Text Framework Programming Guide</p>
  <p class="Heading1">Table of Contents</p>
  <!---------------------------------------------------------------------------------------------------------------> 
  <ul class="NoBullets">
    <li> <b><a href="#Introduction">Introduction</a></b> </li>
    <br>
    <br>
    <li> <b><a href="#textIndexer_Prog">textIndexer Programming</a></b> 
      <ul class="NoBullets">
        <li><a href="#textIndexer_DocSelector_Prog">Document Selector Programming</a></li>
        <li><a href="#textIndexer_PreFilter_Prog">Pre-Filter Programming</a></li>
      </ul>
    </li>
    <br>
    <li> <b><a href="#crossQuery_Prog">crossQuery Programming</a></b> 
      <ul class="NoBullets">
        <li><a href="#crossQuery_QueryParser_Prog">Query Parser Programming</a></li>
        <li><a href="#crossQuery_ResultFormatter_Prog">Result Formatter Programming</a></li>
        <li><a href="#crossQuery_ErrorGen_Prog">Error Generator Programming</a></li>
      </ul>
    </li>
    <br>
    <li> <b><a href="#dynaXML_Prog">dynaXML Programming</a></b> 
      <ul class="NoBullets">
        <li><a href="#dynaXML_DocReqParser_Prog">Document Request Parser Programming</a></li>
        <li><a href="#dynaXML_DocFormatter_Prog">Document Formatter Programming</a></li>
        <li><a href="#dynaXML_ErrorGen_Prog">Error Generator Programming</a></li>
      </ul>
    </li>
    <br>
  </ul>
  <p class="Heading1">Introduction<a name="Introduction"></a></p>
  <!---------------------------------------------------------------------------------------------------------------> 
  This guide describes how to customize the operation of the E<b>X</b>tensible <b>T</b>ext 
  <b>F</b>ramework (<b><i>XTF</i></b>) This document assumes that you have completed 
  the basic installation and configuration described in the <a href="../XTF_Deployment_Guide/XTFDeployGuide.html">XTF 
  Deployment Guide</a>, and that their correct operation has been verified. <br>
  <br>
  The XTF system consists of Java Servlets and tools that permit users to perform 
  Web-based searching and retrieval of electronic documents. Its basic organization 
  of the XTF components can be illustrated as follows: 
  <p align="center"> <a name="SummaryDiagram"></a> <img src="../Common_Art/SummaryDiagram.gif"><br>
    Figure 1: Extensible Text Framework (XTF) Overview </p>
  In this diagram, the basic flow of information is left to right. Document retrieval 
  begins with a Web-based user search query. The <i><b>crossQuery</b></i> servlet 
  checks the query against an index of available documents, and produces a list of 
  matching documents for display in a web browser. Selecting a document from the search 
  results page invokes the <i><b>dynaXML</b></i> servlet, which retrieves and formats 
  the actual document for display in a web browser. The <b><i>textIndexer</i></b> 
  tool shown at the bottom is used to update the document search index whenever documents 
  in the library are added, removed, or updated. <br>
  <br>
  The remainder of this document will examine how to customize the XTF tools and servlets 
  by reprogramming the XSLT templates that define their behavior. 
  <p class="Heading1">textIndexer Programming<a name="textIndexer_Prog"></a></p>
  <!---------------------------------------------------------------------------------------------------------------> 
  As mentioned above in the introduction, the purpose of the <b><i>textIndexer</i></b> 
  tool is to create or update a document search index whenever documents are updated, 
  added to, or removed from the document library. If we would isolate and zoom in 
  on the <b><i>textIndexer</i></b> portion of the <a href="#SummaryDiagram">XTF Overview 
  Diagram</a> shown above, we'd see something like this: <br>
  <p align="center"> <img src="../Common_Art/textIndexer.gif"><br>
    Figure 2: Internal organization of the <b><i>textIndexer</i></b> Tool </p>
  What the diagram shows, is that the <b><i>textIndexer</i></b> uses its <b>Document 
  Selector</b> stylesheet to select which files in the document library need to be 
  indexed. For non-XML document files, the text to index is extracted and converted 
  to XML. This base XML is then processed by the <b>Document Pre-Filter</b> stylesheet 
  to add additional meta-data and/or sectioning information to the text. The resulting 
  filtered XML is then passed on to the actual <b><i>Text Indexer Engine</i></b>, 
  which breaks the text up into smaller overlapping chunks and then adds them to a 
  Lucene based word index. The index can then be used by the <b><i>crossQuery</i></b> 
  servlet to quicky locate files in the document library containing any text requested 
  by the user. Optionally, the <b><i>dynaXML</i></b> servlet can also use the index 
  to highlight in context any matches in the original XML documents when they are 
  viewed. <br>
  <br>
  The <span class="Code">textIndexer.conf</span> file, the <b>Document Selector</b> 
  stylesheet, and the <b>Pre-filter</b> stylesheet together define how the <b><i>textIndexer</i></b> 
  performs the document indexing process. A complete discussion of the <span class="Code">textIndexer.conf</span> 
  file appears in the <a href="../XTF_Deployment_Guide/XTFDeployGuide.html">XTF Deployment 
  Guide</a>, and so will not be discussed in any great depth here. The inner workings 
  of the <b>Document Selector</b> and <b>Pre-Filter</b> stylesheets however, are the 
  subject of the following sub-sections. 
  <div class="IndentL"> 
    <p class="Heading2">Document Selector Programming<a name="textIndexer_DocSelector_Prog"></a></p>
    <!-------------------------------------------------------------------------------------------------------------> 
    The primary purpose of the <b><i>textIndexer</i></b> <b>Document Selector</b> 
    is to select which files in the document library are to be indexed. Since the 
    <b>Document Selector</b> is an XSLT stylesheet, its input is in fact an XML fragment 
    that identifies a single directory in the document library and the files that 
    it contains. The <b>Document Selector</b> stylesheet is invoked one time for each 
    sub-directory encountered in the document library, and the input it receives looks 
    as follows: 
    <pre class="Sample"><b>&lt;directory dirPath="<span class="MacroCode">DirectoryPath</span>"&gt;

    &lt;file fileName="<span class="MacroCode">FileName1</span>"/&gt;
    &lt;file fileName="<span class="MacroCode">FileName2</span>"/&gt;
               <img src="../Common_Art/vDotDotDot.gif" width="8" height="26">
    &lt;file fileName="<span class="MacroCode">FileNameN</span>"/&gt;

&lt;/directory&gt;</b></pre>
    <p> The<span class="Code"> &lt;directory...&gt; </span> tag identifies a single 
      directory in the document library, and the <b><span class="MacroCode">DirectoryPath</span></b> 
      attribute specifies its absolute file system path. Within the <span class="Code"> 
      &lt;directory...&gt; </span> tag, each of the <span class="Code">&lt;file.../&gt; 
      </span>entries identifies one of files found in the directory. Note that <b><span class="MacroCode">FileName1</span></b> 
      through <b><span class="MacroCode">FileNameN</span></b> <i><b><u>do not</u></b></i> 
      contain any path information, since the absolute path that applies to all the 
      file tags is already identified by <b><span class="MacroCode">DirectoryPath</span></b>.</p>
    <p>It is the responsibility of the <b>Document Selecto</b>r XSLT code to output 
      an XML fragment that identifies which of the files in the directory should be 
      indexed. This output XML fragment should take the following form:</p>
    <pre class="Sample"><b>&lt;indexFiles&gt;

    &lt;indexFile fileName      = "<span class="MacroCode">FileName</span>"
               <i>{</i>format       = &quot;<span class="MacroCode">FileFormatID</span>"<i>}</i>
               <i>{</i>preFilter    = &quot;<span class="MacroCode">PreFilterPath</span>"<i>}</i>
               <i>{</i>displayStyle = &quot;<span class="MacroCode">DocumentFormatterPath</span>"<i>}</i>/&gt;
                    <img src="../Common_Art/vDotDotDot.gif" width="8" height="26">

&lt;/indexFiles&gt;</b></pre>
    <p>Note that the output XML consists of a single<span class="Code"> &lt;indexFiles&gt; 
      </span>container tag and one<span class="Code"> &lt;indexFile.../&gt; </span>tag 
      for each document file that needs to be indexed. Within each of the<span class="Code"> 
      &lt;indexFile.../&gt; </span>tags, the following attributes are defined:</p>
    <div class="IndentLR"> <span class="Code">fileName</span><br>
      This attribute identifies the name of a file to be indexed, and should be one 
      of the file names received in the input XML fragment. <br>
      <br>
      <span class="Code">format</span><br>
      This is an optional attribute that defines the format of the file to be indexed. 
      At this time, XML, PDF, HTML, and Plain Text indexing is supported by the <i><b>textIndexer</b></i> 
      tool, and this attribute should be set to the strings<span class="Code"> XML</span>,<span class="Code"> 
      PDF</span>, <span class="Code"> HTML</span>, or<span class="Code"> Text </span>respectively, 
      depending on the native format of the file. If this attribute is not specified, 
      the <i><b>textIndexer</b></i> will try to infer the file type based on the extension 
      for the file. <br>
      <br>
      <span class="Code">preFilter</span><br>
      This is an optional attribute that defines the <b>Pre-Filter </b>stylesheet 
      that the <i><b>textIndexer</b></i> should use on this document file. If not 
      specified, the text for this file will not be filtered before indexing. See 
      the <i><b>textIndexer</b></i> <a href="#textIndexer_PreFilter_Prog">Pre-Filter 
      Programming</a> section for more details about document pre-filtering.<br>
      <br>
      <span class="Code">displayStyle</span><br>
      This is an optional attribute that defines the <b>Document Formatter </b>stylesheet 
      associated with the given file. If specified, the <i><b>textIndexer</b></i> 
      will create a special cache that is used by the <i> <b>dynaXML</b></i> servlet 
      to display selected documents more quickly. If not specified, the cache 
      for the current file is not created. For more details, see the discussion 
      of <a href="../XTF_Under_Hood/XTFUnderHood.html#LazyFiles">Lazy Document 
      Handling</a> in the <a href="../XTF_Under_Hood/XTFUnderHood.html">XTF Under 
      the Hood</a> guide.</div>
    <p>Using these XML input and output specifications shown, a simple document selector 
      might look something like this:</p>
    <pre class="Sample">&lt;xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="2.0"&gt;

  &lt;xsl:template match="directory"&gt;
    &lt;indexFiles&gt;
      &lt;xsl:apply-templates/&gt;
    &lt;/indexFiles&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template match="file"&gt;
    &lt;xsl:if test="ends-with(@fileName,'.pdf')"&gt;
	  &lt;indexFile fileName="{@fileName}" format="PDF"/&gt;
    &lt;/xsl:if&gt;
  &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre>
    <p>In this simple <b>Document Selector</b> example, the first line establishes 
      the<span class="Code"> xsl </span>namespace used in the rest of the stylesheet. 
      Next, the<span class="Code"> &lt;xsl:template match=&quot;directory&quot;&gt; 
      </span>tag looks for the<span class="Code"> &lt;directory...&gt; </span>block 
      in the input XML, and writes out a corresponding<span class="Code"> &lt;indexFiles&gt; 
      </span>block to the output XML. Also the<span class="Code"> &lt;xsl:template&nbsp;match="file"&gt; 
      </span>template is applied to any tags found within the<span class="Code"> &lt;directory...&gt; 
      </span>block.</p>
    <p>The<span class="Code"> &lt;xsl:template&nbsp;match="file"&gt; </span>block 
      is the code that is actually responsible for selecting the files to be indexed. 
      In this example, only files that end in<span class="Code"> .pdf </span>are passed 
      on for indexing, and are assigned the format<span class="Code"> PDF</span>. 
      No <b>Pre-Filter</b> or <b>Document Formatter</b> stylesheets are defined, and 
      so the <i><b>textIndexer</b></i> will not pre-filter or pre-cache display information 
      for<span class="Code"> PDF </span>files.</p>
    <p>Selecting other file types for indexing is as simple as adding more<span class="Code"> 
      &lt;xsl:if...&gt; </span>clauses to the<span class="Code"> &lt;xsl:template 
      match=&quot;file&quot;&gt; </span>block, like this:</p>
    <pre class="Sample">          <img src="../Common_Art/vDotDotDot.gif" width="6" height="26">
  &lt;xsl:template match="file"&gt;
    &lt;xsl:if test="ends-with(@fileName,'.pdf')"&gt;
	  &lt;indexFile fileName="{@fileName}" format="PDF"/&gt;
    &lt;/xsl:if&gt;
    <b><font color="#990000">&lt;xsl:if test="ends-with(@fileName,'.xml')"&gt;
	  &lt;indexFile fileName     = "{@fileName}"
                 preFilter    = &quot;style/textIndexer/default/prefilter.xsl&quot;
                 displayStyle = &quot;style/dynaXML/docFormatter/default/docFormatter.xsl&quot;/&gt;
    &lt;/xsl:if&gt;</font></b>
  &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre>
    <p>This<span class="Code"> second &lt;xsl:if...&gt; </span>block passes XML on 
      files for indexing. Note that the<span class="Code"> &lt;indexFile...&gt; </span>tag 
      doesn't specify the file format, and so the <i><b>textIndexer</b></i> is left 
      to infer that the file type is XML from the file extension. Lastly, the<span class="Code"> 
      &lt;indexFile...&gt; </span>tag also defines a <b>Pre-Filter</b> and a <b>Document 
      Formatter</b> stylesheet for XML files.</p>
    <p>While this simple<b> Document Selector </b>example works, its file selection 
      rules are limited only to checking for certain file extensions. Clearly, all 
      the power of XSLT could be used to construct more complicated selection criteria 
      for files, including ignoring various directories, pulling in meta-data from 
      files or URLs, and so on. For a more complete example of a <b>Document Selector</b> 
      stylesheet, see the default <span class="Code"> style/textIndexer/docSelector.xsl</span> 
      stylesheet.</p>
  </div>
  <div class="IndentL"> 
    <p class="Heading2">Pre-Filter Programming<a name="textIndexer_PreFilter_Prog"></a></p>
    <!-------------------------------------------------------------------------------------------------------------> 
    The primary purpose of <b><i>textIndexer</i></b> <b>Pre-Filters</b> is to modify 
    the XML representation of a document prior to indexing it. The pre-filter used 
    for any particular document is defined by the <b>Document Selector</b>. The main 
    aspects of programming a pre-filter are described in the following six sub-sections. 
    <br>
    <div class="IndentLR"> 
      <p class="Heading3">Defining the XTF Namespace</p>
      <br>
      <!-----------------------------------------------------------------------------------------------------------> 
      For the <b><i>textIndexer</i></b> pre-filter to work properly, an<span class="Code"> 
      xtf: </span>namespace must be declared at the top of the pre-filter. To do this, 
      simply add the following attribute to the<span class="Code"> &lt;xsl:stylesheet<span class="BasicStyle">...</span>&gt; 
      </span>tag at the top of the pre-filter: <br>
      <br>
      <div class="Sample"> <span class="Code">xmlns:xtf="http://cdlib.org/xtf"</span> 
      </div>
      <br>
      Defining an<span class="Code"> xtf: </span>namespace in this way and then prefixing 
      <b><i>textIndexer</i></b> specific attributes with it allows the <b><i>textIndexer</i></b> 
      to distinguish its own attributes from other ones in the filtered document. 
    </div>
    <div class="IndentLR"> 
      <p class="Heading3">Preventing Text from being Indexed</p>
      <br>
      <!-----------------------------------------------------------------------------------------------------------> 
      There will be times when the text within certain tags in the XML representation 
      for a document should not be indexed (e.g.: versioning information about the 
      original XML file format.) The XSLT pre-filter can be prevent such tags and 
      their associated text from being indexed. There are two possible ways to do 
      this: 
      <ol>
        <li class="ListItem"> Standard XSLT programming can be used to eliminate the 
          tag and its text entirely.<br>
        </li>
        <br>
        <li class="ListItem"> A special <span class="Code">noindex</span> attribute 
          can be added to the tag to tell the <b><i>textIndexer</i></b> to ignore 
          its contents when indexing. </li>
      </ol>
      Eliminating certain tags through the use of standard XSLT techiques has the 
      advantage that it saves space. The tag's text is not added to the search index, 
      nor is it stored by the fast retrieval database for later display by the <b><i>dynaXML</i></b> 
      servlet. By contrast, the <span class="Code">noindex</span> attribute simply 
      prevents the tag's text from being indexed. The text is still stored in the 
      fast retrieval database so that the <b><i>dynaXML</i></b> servlet can display 
      the text if necessary. <br>
      <br>
      A snippet of code showing the use of the <span class="Code"> noindex </span> 
      attribute can be found in the sample <span class="Code"> preFilter.xml </span> 
      file that is included with the default XTF installation. It looks as follows: 
      <br>
      <pre class="Sample"><b>&lt;xsl:template match="teiHeader"&gt;

    &lt;xsl:copy&gt;
        &lt;xsl:copy-of select="@*"/&gt;
        <font color="#990000">&lt;xsl:attribute name="xtf:noindex" select="'true'"/&gt;</font>
        &lt;xsl:apply-templates/&gt;
    &lt;/xsl:copy&gt;

&lt;/xsl:template&gt;</b></pre>
      Notice that the <span class="Code"> noindex </span> attribute when used in the 
      pre-filter is prefixed with <span class="Code"> xtf: </span>. This is the namespace 
      used in XTF tags and attributes to prevent collisions with similarly named tags 
      and attributes defined by other programs.<br>
      <br>
      Finally, it should be mentioned that the <span class="Code">noindex</span> attribute 
      has two forms: <br>
      <br>
      <div class="IndentLR">
        <pre class="Code">noindex = true/yes, false/no</pre>
      </div>
      and <br>
      <br>
      <div class="IndentLR">
        <pre class="Code">index   = false/no, true/yes</pre>
      </div>
      Both forms enable or disable indexing, but their logic is inverted so that the 
      XSLT programmer can choose the wording that makes the most sense in any given 
      situation. 
      <p class="Heading3">Controlling Proximity</p>
      <!-----------------------------------------------------------------------------------------------------------> 
      If an XTF user specifies a list of words to search for, the <b><i>crossQuery</i></b> 
      servlet will rank any matching words that are closer together as better matches 
      than ones that are far apart. This is what is known as <b><i>proximity searching</i></b>. 
      <br>
      <br>
      There are times however when simple proximity matches will produce undesired 
      results. For example, consider the case where a query matches some words in 
      two different places in a document. For the first match, the words are very 
      close together but in two different chapters' tags. For the second match, the 
      words are all in the same chapter, but slightly further apart. In this case, 
      the proximity search mechanism will incorrectly give a higher score to match 
      with the words that are closer together but split across two chapters. <br>
      <br>
      To correct for these kinds of situations, the pre-filter can insert a <b><i>proximity 
      break attribute</i></b> into a tag. Doing so effectively puts an infinite distance 
      between the tag with the break and the text before it, thus entirely preventing 
      proximity matches from being found that span the two tags. For example, to solve 
      the "proximity across chapters" problem described above, a pre-filter might 
      include some code like this: <br>
      <br>
      <pre class="Sample"><b>&lt;xsl:template <font color="#990000">match="chapter"</font>&gt;

    &lt;xsl:copy&gt;
        &lt;xsl:copy-of select="@*"/&gt;
        <font color="#990000">&lt;xsl:attribute name="xtf:proximitybreak" select="'true'"/&gt;</font>
        &lt;xsl:apply-templates/&gt;
    &lt;/xsl:copy&gt;

&lt;/xsl:template&gt;</b></pre>
      In this example, the important code is on first and fourth lines. The first 
      line tells the pre-filter to look for "chapter" tags. And when it finds one, 
      the fourth line adds a proximity break attribute. Adding this code to the pre-filter 
      would ensure that proximity matches are never found that span two "chapter" 
      tags. <br>
      <br>
      Sometimes it may still be desirable to find proximity matches across sections, 
      but deemphasize them compared to matches found entirely within a section. In 
      this case, the<span class="Code"> sectionBump </span>attribute can be used in 
      place of a proximity break. Unlike the<span class="Code"> proximityBreak </span>tag, 
      the<span class="Code"> sectionBump </span> tag can be told how much distance 
      (as a number of words) to introduce between two adjacent sections. For example, 
      this code: <br>
      <br>
      <pre class="Sample"><b>&lt;xsl:template <font color="#990000">match="chapter"</font>&gt;

    &lt;xsl:copy&gt;
        &lt;xsl:copy-of select="@*"/&gt;
        <font color="#990000">&lt;xsl:attribute name="xtf:sectionBump" select="10"/&gt;</font>
        &lt;xsl:apply-templates/&gt;
    &lt;/xsl:copy&gt;

&lt;/xsl:template&gt;</b></pre>
      would separate adjacent chapters from eachother by ten words. Proximity matches 
      across chapters would still be found, but they would be considered 10 words 
      further apart (and therefore less relevant) than similar matches found entirely 
      within a single section. <br>
      <br>
      Just as it may be desirable to deemphasize proximity matches across adjacent 
      sections, it may also be desireable to control proximity matches across sentence 
      boundaries. To accomplish this, the sentenceBump attribute can be added to a 
      tag like this: <br>
      <br>
      <pre class="Sample"><b>&lt;xsl:template <font color="#990000">match="DocText"</font>&gt;

    &lt;xsl:copy&gt;
        &lt;xsl:copy-of select="@*"/&gt;
        <font color="#990000">&lt;xsl:attribute name="xtf:sentenceBump" select="5"/&gt;</font>
        &lt;xsl:apply-templates/&gt;
    &lt;/xsl:copy&gt;

&lt;/xsl:template&gt;</b></pre>
      In this example, a hypothetical tag under which all other document tags and 
      text exist has its sentenceBump value set to 5 words. This effectively separates 
      the end of one sentence from the beginning of the next by five words. Doing 
      so makes proximity matches across sentences less relevant than a similar proximity 
      match entirely within a single sentence. 
      <p class="Heading3">Sectioning Documents</p>
      <!-----------------------------------------------------------------------------------------------------------> 
      Another attribute that can be added to document tags is the<span class="Code"> 
      sectionType </span>attribute. This attribute allows you to assign names to tags 
      witin a document. Doing so would allow permit advanced user queries that only 
      search for text in specific section types. Consider the following example: <br>
      <br>
      <pre class="Sample"><b>&lt;xsl:template <font color="#990000">match="ChapterTitle"</font>&gt;

    &lt;xsl:copy&gt;
        &lt;xsl:copy-of select="@*"/&gt;
        <font color="#990000">&lt;xsl:attribute name="xtf:sectionType" select="'ChapterTitle'"/&gt;</font>
        &lt;xsl:apply-templates/&gt;
    &lt;/xsl:copy&gt;

&lt;/xsl:template&gt;</b></pre>
      This XSLT code simply labels the text indexed for a chapter title with a "ChapterTitle" 
      section type. With the text labeled in this manner, the query page presented 
      to the user could provide an advanced search option to look for text only in 
      chapter titles. We'll talk more about how to actually do this in the section 
      below on <a href="#crossQuery_QueryParser_Prog">programming the <b><i>crossQuery</i></b> 
      servlet's Query Parser Stylesheet</a>. <br>
      <br>
      One other thing to mention about <span class="Code">sectionType</span> attributes 
      is that they may be used in nested tags. The <b><i>textIndexer</i></b> maintains 
      an internal stack of nested section types, and correctly restores previous section 
      types when a given section/tag ends. 
      <p class="Heading3">Relevance Boost</p>
      <!-----------------------------------------------------------------------------------------------------------> 
      There may be times when it is useful to boost or deemphasize the relevance of 
      text in a particular part of a document. Consider the case where you had a document 
      that was a book of quotations. In such a document, it might make sense to boost 
      the relevance of the text in the actual quotations as compared to any text that 
      discussions the quotations. To facilitate this, the <b><i>textIndexer</i></b> 
      pre-filter provides a <b><i>wordboost</i></b> attribute. The following example 
      illustrates its use: <br>
      <br>
      <pre class="Sample"><b>&lt;xsl:template <font color="#990000">match="Quotation"</font>&gt;

    &lt;xsl:copy&gt;
        &lt;xsl:copy-of select="@*"/&gt;
        <font color="#990000">&lt;xsl:attribute name="xtf:wordboost" select="1.5"/&gt;</font>
        &lt;xsl:apply-templates/&gt;
    &lt;/xsl:copy&gt;

&lt;/xsl:template&gt;</b></pre>
      This XSLT code simply boosts text found in <span class="Code">Quotation</span> 
      tags to be 1.5 times more relevant than non-boosted text in the document. Conversely, 
      to deemphasize text simply use a value between zero and one (e.g., a boost of 
      0.5 would make text half as relevant when searching.) <br>
      <br>
      As with <span class="Code">section</span> attributes, the wordboost attribute 
      may be used in nested tags. The <b><i>textIndexer</i></b> maintains an internal 
      stack of nested boost values, and correctly restores previous values when a 
      given section/tag ends. Note however that boost values in nested tags <b><i>do 
      not</i></b> accumulate. That is, a tag with a boost value of 1.5 will boost 
      the relevance of its words by 1.5, regardless of the boost values applied to 
      any tags that contain it. 
      <p class="Heading3">Adding or Marking Meta-Data</p>
      <!-----------------------------------------------------------------------------------------------------------> 
      There are times when it is useful to record Meta-Data for a document. Meta-Data 
      is simply information about a document that is not part of the document 
      text itself. The author name, document publication date, and document revision 
      are all examples of Meta-Data. The <b><i>textIndexer</i></b> system supports 
      the concept of Meta-Data through the use of the <span class="Code">meta</span> 
      attribute. Using the pre-filter to add this attribute to a tag causes name 
      of the tag and its contents to be recorded in a special Meta-Data section 
      of the index for the document. For example: <br>
      <br>
      <pre class="Sample"><b>&lt;xsl:template <font color="#990000">match="PublicationInfo"</font>&gt;

    &lt;xsl:copy&gt;
        &lt;xsl:copy-of select="@*"/&gt;
        <font color="#990000">&lt;xsl:attribute name="xtf:meta" select="'true'"/&gt;</font>
        &lt;xsl:apply-templates/&gt;
    &lt;/xsl:copy&gt;

&lt;/xsl:template&gt;</b></pre>
      <p>This snippet of pre-filter code would take any tag with the name <span class="Code">PublicationInfo</span> 
        and add a <span class="Code">meta</span> attribute to it, thus telling 
        the <b><i>textIndexer</i></b> to add the publication info to the meta-data 
        index for the current document rather than the main text index. Once meta-data 
        has been recorded for a document, it can be searched by modifying the 
        <b><i>crossQuery</i></b> servlet's Query Parser Stylesheet to generate 
        meta search requests. Doing so is described in detail below in the <a href="#crossQuery_QueryParser_Prog">Query 
        Parser Programming</a> section below.</p>
      <p>Another way in which meta-data for a document can be used is as a query 
        <i><b> sort key</b></i>. Sort keys are used by the <i><b>crossQuery</b></i> 
        servlet to reorder how query matches are displayed for the user. To use 
        a meta-field as a sort key, its contents must not be tokenized. Since 
        tokenizing is turned on by default to make a meta-data field searchable, 
        the pre-filter code that processes meta-data must explicitly turn tokenizing 
        off. This is accomplished as follows:</p>
      <pre class="Sample"><b>&lt;xsl:template match="PublicationInfo"&gt;

    &lt;xsl:copy&gt;
        &lt;xsl:copy-of select="@*"/&gt;
        &lt;xsl:attribute name="xtf:meta" select="'true'"/&gt;
        <font color="#990000">&lt;xsl:attribute name="xtf:tokenize" select="'no'"/&gt;</font>
        &lt;xsl:apply-templates/&gt;
    &lt;/xsl:copy&gt;

&lt;/xsl:template&gt;</b></pre>
      <p>Like the previous example, this pre-filter code would take any tag with 
        the name <span class="Code">PublicationInfo</span> and mark it as meta-data. 
        But the addition of the line of code shown in red disables tokenizing 
        so that the meta-data can be used as a sort key by the <i> <b>crossQuery</b></i> 
        servlet.</p>
      <p>It is important to note that since meta-data must be tokenized to be 
        searchable, and it must not be tokenized to be used as a sort key, meta-based 
        searching and sorting operations are effectively mutually exclusive. If 
        you want to perform both searching and sorting on a collection of meta-data, 
        you'll need to add code to your prefilter to produce two copies of that 
        meta-data: one copy for searching that is tokenized, and one copy for 
        sorting that is not tokenized.</p>
      
      <p class="Heading3">Pre-Filters and Lazy-Tree Building</p>
      <!-----------------------------------------------------------------------------------------------------------> 
      <p>The XTF system makes use of <i><b>Lazy Tree</b></i> files to help speed 
        document retrieval and to help the <i><b>dynaXML</b></i> applet highlight 
        search results in context. By default, lazy tree files are generated at 
        index time by the <i><b>textIndexer</b></i>. However, through the use 
        of the<span class="Code"> -nobuildlazy </span> command-line argument, 
        the <i><b>textIndexer</b></i> can be instructed to not build the lazy 
        tree files. In this case, the <i><b>dynaXML</b></i> servlet will build 
        the lazy trees files when it needs them.<br>
      </p>
      <p>If the<span class="Code"> -nobuildlazy </span> command-line is used to 
        delay the building of lazy tree information until document retrieval, 
        it is imperative that the prefilter specified by the<span class="Code"> 
        docSelector.xsl </span>stylesheet is the same one specified by the <i><b>dynaXML</b></i>'s<span class="Code"> 
        docReqParser.xsl </span>stylesheet. If the two stylesheets use different 
        prefilters, the search result information generated by the <i><b>crossQuery</b></i> 
        servlet will not match the highlighting information in the lazy tree files 
        generated by the dynaXML servlet, and chaos will ensue. </p>
    </div>
 
    <p class="Heading2">Summary<a name="textIndexer_PreFilter_Prog"></a></p>
    <!-------------------------------------------------------------------------------------------------------------> 
    <p>In closing, a few additional facts should be mentioned about the attributes 
      supported by the XTF system:</p>
    <ol>
      <li class="ListItem"> All the examples above show the <b><i>textIndexer</i></b> 
        pre-filter adding attributes to the XML representation for a document. However, 
        for native XML documents, the attributes could have simply been embedded in 
        the original source document tags. The disadvantage of doing so, however, 
        is that the attributes in every XML document would need to be updated whenever 
        indexing changes are made to the XTF system.<br>
        <br>
      </li>
      <li class="ListItem"> A single tag can be assigned more than one attribute. 
        For example, a tag could be assigned both a word boost and a section title 
        if desired. Note however that some combinations (like <span class="Code">sectionType</span> 
        + <span class="Code">proximitybreak</span>) are redundant and unnecessary.<br>
        <br>
      </li>
      <li class="ListItem"> Currently, when a <span class="Code">meta</span> attribute 
        is added to a tag, all the other XTF specific attributes are ignored (e.g., 
        <span class="Code">wordboost</span>, <span class="Code">proximitybreak</span>, 
        etc.) </li>
    </ol>
    Finally, it should be noted that the sample <span class="Code">style/textIndexer/common/preFilterCommon.xsl</span> 
    beneath the base XTF directory (i.e., <span class="Code">XTF_HOME</span>) 
    is a good starting point for creating your own customized pre-filters. </div>
  <br>
  <!-- textIndexer --> 
  <p class="Heading1">crossQuery Programming<a name="crossQuery_Prog"></a></p>
  <!---------------------------------------------------------------------------------------------------------------> 
  The <b><i>crossQuery</i></b> servlet previously shown in the XTF overview allows 
  users to search the document library for particular words or phrases. If we look 
  more closely at the <b><i>crossQuery</i></b> portion of the <a href="#SummaryDiagram">XTF 
  Overview Diagram</a>, we'll see something like this: <br>
  <p align="center"> <img src="../Common_Art/crossQuery.gif"><br>
    Figure 3: Internal organization of the <b><i>crossQuery</i></b> Servlet </p>
  Once again, the basic flow of information in this diagram is left to right. A document 
  search begins with a the user specifying some text to search for on a web page. 
  The query is assembled into a URL of the form: <br>
  <br>
  <div class="Sample"> <span class="Code"> http://<span class="MacroCode">yourserver</span>:8080/xtf/servlet/org.cdlib.xtf.crossQuery.CrossQuery?text=<span class="MacroCode">TextToFind</span> 
    </span> </div>
  <br>
  This query URL is then passed on to the <i><b>crossQuery</b></i> servlet for processing. 
  The first thing the servlet does is translate the query URL into an XML query that 
  the <b><i>crossQuery</i></b> search engine can actually understand. This translation 
  is accomplished by the XSLT based <b>Query Parser</b> (<span class="Code">queryParser.xsl</span>.) 
  <br>
  <br>
  The <b><i>crossQuery</i></b> search engine then uses the XML query to look for occurences 
  of the specified text in the document index. Any matches that are found in the index 
  are assembled into a list of XML tags, and passed on to <b>Result Formatter</b> 
  stylesheet (<span class="Code">resultFormatter.xsl</span>.) The <b>Result Formatter</b> 
  stylesheet then converts the list of matches into HTML for review by the user. <br>
  <br>
  The remaining two subsections describe in detail how to write <b>Query Parser</b> 
  and <b>Result Formatter</b> XSLT code to carry out the necessary translations. 
  <div class="IndentL"> 
    <p class="Heading2">Query Parser Programming<a name="crossQuery_QueryParser_Prog"></a></p>
    <!-------------------------------------------------------------------------------------------------------------> 
    As previously noted, the <b>Query Parser</b> is responsible for translating a 
    URL based query into an XML query that the search engine can actually understand. 
    Consider the following pseudo-query: <br>
    <br>
    <div class="IndentLR"> <span class="Code">Find all occurences of "man" and "war" 
      but not "Man of War".</span> </div>
    <br>
    What we're trying to find here is any document containing both "man" and "war", 
    but not "Man of War", which is a kind of jellyfish. In theory, the web page into 
    which the user types the search query could take a simplified English-like representation 
    of the query with the form: <br>
    <br>
    <div class="IndentLR"> <span class="Code">find man and war but not "Man of 
      War"</span> </div>
    <br>
    but writing an XSLT parser to process it would be a complicated endeavor. To simplify 
    things, we'll assume that the web page has a field that accepts all the words 
    or phrases to find, and another field that accepts all the words or phrases to 
    exclude. For our specific example, the user would type <br>
    <br>
    <div class="IndentLR"> <span class="Code"> man war </span> </div>
    <br>
    into the <b>text to find</b> field, and <br>
    <br>
    <div class="IndentLR"> <span class="Code"> "Man of War" </span> </div>
    <br>
    into the <b>text to exclude</b> field. Note that each word or phrase is separated 
    from the others by a space, and that an exact phrase (like <span class="Code">Man 
    of War</span>) is enclosed in double-quotes to differentiate it from a list of 
    individual words. The resulting query URL that would be passed to the <b><i>crossQuery</i></b> 
    servlet would then look something like this: <br>
    <br>
    <div class="Sample"> <span class="Code"> http://<span class="MacroCode">yourserver</span>:8080/xtf/servlet/org.cdlib.xtf.crossQuery.CrossQuery?text=man+war&text-exclude=%22Man+of+War%22 
      </span> </div>
    <br>
    Notice that the first part of the URL (everything before the <b>?</b> symbol) 
    invokes the <b><i>crossQuery</i></b> servlet, and second part of the URL (everything 
    after the <b>?</b> symbol) defines the search to be performed. Also notice that 
    search to be performed is represented by two parameters: <br>
    <br>
    <table width="90%" cellpadding="0" cellspacing="12">
      <tr> 
        <td width="213" align="right" valign="baseline" class="Code">text=man+war</td>
        <td width="246" valign="baseline"><span class="BaseStyle">The list of 
          words search for.</span></td>
      </tr>
      <tr> 
        <td width="213" align="right" valign="baseline" class="Code">text-exclude=%22Man+of+War%22</td>
        <td width="246" valign="baseline"><span class="BaseStyle">The phrase to 
          exclude from the search.</span></td>
      </tr>
    </table>
    <br>
    These two parameters carry the "find" and "exclude" semantics represented by the 
    two fields of our imagined query Web-Page. As is typical for URLs, the spaces 
    in each parameter have been replaced with plus signs (<span class="Code">+</span>), 
    and the double-quote characters have been replaced with their ANSI equivalent 
    hexadecimal values. <br>
    <br>
    Since the <b>Query Parser</b> is written in XSLT, it actually expects an XML document 
    as its input, and not a URL like the one presented above. Consquently, the <b><i>crossQuery</i></b> 
    servlet preprocesses the query URL and turns it into an XML input fragment for 
    the <b>Query Parser</b> to translate. In general, the input XML passed to the 
    <b>Query Parser</b> looks like this: 
    <pre class="Sample"><b>&lt;parameters&gt;

  &lt;param name="<span class="MacroCode">ParamName</span>" value="<span class="MacroCode">ParamValue</span>"&gt;
      <span class="MacroCode">Token</span> | <span class="MacroCode">Phrase</span>
      <span class="MacroCode">Token</span> | <span class="MacroCode">Phrase</span>
           <img src="../Common_Art/vDotDotDot.gif" width="8" height="26">
  &lt;/param&gt;
      <img src="../Common_Art/vDotDotDot.gif">
&lt;/parameters&gt;</b></pre>
    where <span class="MacroCode">Token</span> specifies a single word, and has the 
    form: <br>
    <br>
    <div class="Sample"> <span class="Code"> &lt;token value="<span class="MacroCode">Word</span>" 
      isWord = "<span class="MacroCode">YesOrNo</span>"/&gt; </span> <br>
      <br>
      where <br>
      <br>
      <table cellpadding="0" cellspacing="12">
        <tr> 
          <td width="16%" align="right" valign="top" class="Code"> value="<span class="MacroCode">Word</span>" 
          </td>
          <td><span class="BaseStyle">is the actual word or symbol extracted from 
            the URL.</span></td>
        </tr>
        <tr> 
          <td width="16%" align="right" valign="top" class="Code"> isWord="<span class="MacroCode">YesOrNo</span>" 
          </td>
          <td><span class="BaseStyle">identifies whether the token is a word or 
            punctuation symbol.</span></td>
        </tr>
      </table>
    </div>
    <br>
    and <span class="MacroCode">Phrase</span> specifies an entire phrase extracted 
    as a single string, with the form: <br>
    <br>
    <div class="Sample"> 
      <pre class="Code">&lt;phrase value="<span class="MacroCode">StringOfWords</span>"&gt;
    <span class="MacroCode">Token</span>
      <img src="../Common_Art/vDotDotDot.gif">
    <span class="MacroCode">Token</span>
&lt;/phrase&gt;
</pre>
      where <br>
      <br>
      <table cellpadding="0" cellspacing="12">
        <tr> 
          <td width="16%" align="right" valign="top" class="Code"> value="<span class="MacroCode">StringOfWords</span>" 
          </td>
          <td><span class="BaseStyle">is the entire phrase extracted from the 
            URL as a single string.</span></td>
        </tr>
        <tr> 
          <td width="16%" align="right" valign="top" class="Code"> <span class="MacroCode">Token</span>...<span class="MacroCode">Token</span> 
          </td>
          <td> <span class="BaseStyle"> is the original phrase broken down into 
            individual token tags for each word or symbol in the phrase. </span> 
          </td>
        </tr>
      </table>
    </div>
    <br>
    For our particular example URL, the input XML fragment passed to the <b>Query 
    Parser</b> would be: <br>
    <br>
    <pre class="Sample"><b>&lt;parameters&gt;

  &lt;param name="text" value="man war"&gt;
     &lt;token value="man" isWord="yes"/&gt;
     &lt;token value="war" isWord="yes"/&gt;
  &lt;/param&gt;

  &lt;param name="text-exclude" value="&#34;Man of War&#34"&gt;
     &lt;phrase value="Man of War"/&gt;
         &lt;token value="Man" isWord="yes"/&gt;
         &lt;token value="of"  isWord="yes"/&gt;
         &lt;token value="War" isWord="yes"/&gt;
     &lt;/phrase&gt;
  &lt;/param&gt;

&lt;/parameters&gt;</b></pre>
    As mentioned before, it is the job of the the <b>Query Parser</b> XSLT code to 
    translate the above input into an XML query that the <b><i>crossQuery</i></b> 
    search engine understands. The general format of an XML query passed to the search 
    engine has the form: <br>
    <br>
    <pre class="Sample"><b>&lt;query indexPath="<span class="MacroCode">LocationOfIndexDBToUse</span>" style="<span class="MacroCode">ResultFormatterLocation</span>"&gt;

    <span class="MacroCode">QueryElements</span>

&lt;/query&gt;</b></pre>
    <p>The <span class="Code">&lt;query...&gt;</span> tag is always the outermost 
      tag in a query, containing all the other tags that define the query to be 
      performed. Through its <span class="Code">indexPath="<span class="MacroCode">LocationOfIndexDBToUse</span>&quot;</span> 
      attribute, this tag identifies the Lucene index to use when performing the 
      query. Through its <span class="Code">style="<span class="MacroCode">ResultFormatterLocation</span>"</span> 
      attribute, it also defines the path to the <a href="#crossQuery_ResultFormatter_Prog">Result 
      Formatter</a> XSLT stylesheet that will format the query results. For both 
      attributes, the path specified is relative to the base install path for 
      the XTF system (i.e.,<span class="Code"> XTF_HOME</span>.) <br>
      <br>
      Within the <span class="Code">&lt;query...&gt;</span> tag, the <span class="MacroCode">QueryElements</span> 
      identify the type of query to perform. The simplest query that can be performed 
      is a query for a single word, or <i><b>term</b></i>. It has the form:</p>
    <pre class="Sample"><b>&lt;term field=&quot;<span class="MacroCode">FieldToSearch</span>&quot;&gt;

    <span class="MacroCode">WordToFind</span>

&lt;/term&gt;</b></pre>
    <p>This tag indicates that we wish to find a single word in the field identified 
      by <span class="Code">field=</span>&quot;<span class="MacroCode">FieldToSearch</span>&quot; 
      . If we wish to search the main text of a document, <span class="MacroCode">FieldToSearch</span> 
      should be set to <span class="Code"><span class="Code">text</span></span>. 
      If we wish to search meta data for a document, we would use a meta-data 
      field name instead, like <span class="Code">creator</span> or <span class="Code">subject</span>. 
      Once the search field been identified, the single word we actually wish 
      to find should substituted for <span class="MacroCode">WordToFind</span>.<br>
      <br>
      The next simplest query to perform is a <i><b>phrase query</b></i>. It has 
      the form:</p>
    <pre class="Sample"><b>&lt;phrase field=&quot;<span class="MacroCode">FieldToSearch</span>&quot;&gt;
    <span class="MacroCode">Term</span>
    <span class="MacroCode">Term</span>
      <img src="../Common_Art/vDotDotDot.gif">
&lt;/phrase&gt;</b></pre>
    <p>This query contains one or more term tags that together identify a phrase 
      to find, rather than a single word. For example, the <b>&quot;Man of War&quot;</b> 
      phrase in our sample query above would be constructed using the <span class="Code">&lt;phrase...&gt;</span> 
      and <span class="Code">&lt;term...&gt;</span> tags as follows:</p>
    <pre class="Sample"><b>&lt;phrase field=&quot;text&quot;&gt;
    &lt;term&gt; Man &lt;/term&gt;
    &lt;term&gt; of  &lt;/term&gt;
    &lt;term&gt; War &lt;/term&gt;
&lt;/phrase&gt;</b></pre>
    <p>It should be noted from this example the <span class="Code">field=&quot;<span class="MacroCode">FieldToSearch</span>&quot;</span> 
      attribute doesn't need to be specified in each of the <span class="Code">&lt;term...&gt;</span> 
      tags, since the enclosing <span class="Code">&lt;phrase...&gt;</span> tag 
      has already identified the field to be searched.</p>
    <p>The one remaining query element that we would need to construct a complete 
      query for our man and war not &quot;Man of War&quot; example is the <i><b>query 
      clause</b></i>. It has the form: </p>
    <pre class="Sample"><b>&lt;<span class="MacroCode">ClauseType</span> field=&quot;<span class="MacroCode">FieldToSearch</span>&quot;&gt;
    <span class="MacroCode">Term</span> | <span class="MacroCode">Clause</span>
    <span class="MacroCode">Term</span> | <span class="MacroCode">Clause</span>
         <img src="../Common_Art/vDotDotDot.gif">
&lt;/<span class="MacroCode">ClauseType</span>&gt;</b></pre>
    Where valid <span class="MacroCode">ClauseType</span> values are <span class="Code">and</span>, 
    <span class="Code">or</span>, <span class="Code">not</span>, <span class="Code">near</span>, 
    <span class="Code">phrase</span>, and <span class="Code">exact</span>. Each 
    of these clause types do pretty much what you would expect: 
    <ul>
      <li class="ListItem"> The <span class="Code">and</span> clause requires 
        all its sub-terms/phrases/clauses to be present for a match to occur. 
      </li>
      <li class="ListItem"> The <span class="Code">or</span> clause requires any 
        one of its sub-terms/phrases/clauses to be present for a match to occur. 
      </li>
      <li class="ListItem"> The <span class="Code">not</span> clause requires 
        that none of its sub-terms/phrases/clauses are present for a match to 
        occur. </li>
      <li class="ListItem"> The <span class="Code">near</span> clause requires 
        all its sub-terms/phrases/clauses to be <b><i>near</i></b> each other 
        for a match to occur. The definition of <b><i>near</i></b> is fairly complicated, 
        and will not be discussed here. See the <a href="../XTF_Tag_Reference/XTFTagRef.html#crossQuery_QueryParser_Tags">Query 
        Parser tag reference</a> for an in-depth description of the <span class="code">near</span> 
        clause. </li>
      <li class="ListItem">The <span class="Code">exact</span> clause operates 
        just like the<span class="Code"> phrase </span>clause, except that it 
        matches the entire contents of a field only, whereas a<span class="Code"> 
        phrase </span>clause can match anywhere within the field. </li>
    </ul>
    Now, for the sample query we discussed above: <br>
    <br>
    <div class="IndentLR"> <span class="Code">man and war not "Man of War"</span> 
    </div>
    <br>
    the complete query would look as follows: 
    <pre class="Sample"><b>&lt;query indexPath=&quot;./index&quot; style="./style/crossQuery/resultFormatter.xsl"&gt;
    &lt;and field=&quot;text&quot;&gt;
        &lt;term&gt man &lt;/term&gt;
        &lt;term&gt war &lt;/term&gt;
        &lt;not&gt;
            &lt;phrase&gt;
                &lt;term&gt Man &lt;/term&gt;
                &lt;term&gt of  &lt;/term&gt;
                &lt;term&gt War &lt;/term&gt;
            &lt;/phrase&gt;
        &lt;/not&gt;
    &lt;/and&gt;
&lt;/query&gt;</b></pre>
    At this point, the trick is to write a <span class="Code">queryParser.xsl</span> 
    stylesheet that converts the given input XML fragment into the output XML 
    query shown above. Unfortunately, writing XSLT is well beyond the scope of 
    this document and will not be discussed here. The good news however is that 
    the sample <span class="Code">queryParser.xsl</span> included with the XTF 
    installation performs the necessary query conversion illustrated in this example, 
    and is a good starting point for creating your own custom Query Parser. <br>
    <br>
    It should also be noted that the various query tags illustrated here have 
    been shown in their simplest form for the sake of clarity. For example the 
    <span class="MacroCode">Query</span> tag has additional attributes that allow 
    query matches to be returned a few at a time. This allows the Result Formatter 
    to display a short page of search results rather than a single page containing 
    every result in the repository. Another thing to note is that <span class="MacroCode">Phrase</span> 
    tags are in fact recursive, and can contain sub-phrases or clauses (not just 
    <span class="MacroCode">Term</span> tags.) For a complete description of query 
    tags and the attributes they support, please refer to the <a href="../XTF_Tag_Reference/XTFTagRef.html#crossQuery_QueryParser_Tags">Query 
    Parser Tag Reference</a>. 
    <p class="Heading2">Result Formatter Programming<a name="crossQuery_ResultFormatter_Prog"></a></p>
    <!-------------------------------------------------------------------------------------------------------------> 
    What the filter does<br>
    Input<br>
    Output<br>
    <p class="Heading2">Error Generator Programming<a name="crossQuery_ErrorGen_Prog"></a></p>
    <!-------------------------------------------------------------------------------------------------------------> 
    What the filter does<br>
    Input<br>
    Output<br>
  </div>
  <br>
  <!-- crossQuery --> 
  <p class="Heading1">dynaXML Programming<a name="dynaXML_Prog"></a></p>
  <!-------------------------------------------------------------------------------------------------------------> 
  This section provides... <br>
  <p align="center"> <img src="../Common_Art/dynaXML.gif"><br>
    Figure 3: Internal organization of the <b><i>crossQuery</i></b> Servlet </p>
  <div class="IndentL"> 
    <p class="Heading2">Document Request Parser Programming<a name="dynaXML_DocReqParser_Prog"></a></p>
    <!-------------------------------------------------------------------------------------------------------------> 
    What the filter does<br>
    Input<br>
    Output<br>
    <p class="Heading2">Document Formatter Programming<a name="dynaXML_DocFormatter_Prog"></a></p>
    <!-------------------------------------------------------------------------------------------------------------> 
    The <b>Document Formatter</b> stylesheet receives as its input the requested XML 
    document. For its output it shold produce an HTML based document web-page that 
    can be viewed in the user's browser. <br>
    <br>
    The XML document passed by the dynaXML servlet to the Document Formatter Stylesheet 
    consists of the original XML source document with the following additions: <br>
    <ul>
      <li class="ListItem"> Any added <a href="../XTF_Tag_Reference/XTFTagRef.html#textIndexer_Tag_Ref">attributes</a> 
        introduced by the <b><i>textIndexer</i></b> <b>Pre-Filter</b> when the document 
        was indexed. </li>
      <li class="ListItem"> If a query accompanied the document request, a<span class="Code"> 
        snippets </span>tag will appear at the top of the document, summarizing of 
        all the hits found within the document. </li>
      <li class="ListItem"> If a query accompanied the document request, then zero 
        or more<span class="Code"> hit </span>and<span class="Code"> term </span>tags 
        will appear around matching text in the main body of the document for the 
        given query. </li>
    </ul>
    The additional tags and attributes added by the <b><i>textIndexer</i></b> and 
    the <b><i>dynaXML</i></b> servlet are prefixed with an<span class="Code"> xtf: 
    </span>namespace to clearly differentiate them from other tags in the XML document. 
    <br>
    <br>
    The<span class="Code"> snippets </span> summary tag will have the following form: 
    <pre class="Sample"><span class="Code">&lt;snippets&gt;
  <span class="MacroCode">Snippet</span>
  <span class="MacroCode">Snippet</span>
    <img src="../Common_Art/vDotDotDot.gif">
&lt;/snippets&gt;</span></pre>
    where each <span class="MacroCode">Snippet</span> is a <b><i>dynaXML</i></b><span class="Code"> 
    <a href="../XTF_Tag_Reference/XTFTagRef.html#dynaXML_DocFormatter_Snippet">snippet</a> </span>tag that summarizes one query 
    match in the requested document. 
    <p class="Heading2">Error Generator Programming<a name="dynaXML_ErrorGen_Prog"></a></p>
    <!-------------------------------------------------------------------------------------------------------------> 
    What the filter does<br>
    Input<br>
    Output<br>
  </div>
  <br>
  <!-- dynaXML --> <!---------------------------------------------------------------------------------------------------------------><br>
</div>
</body>

</html>
