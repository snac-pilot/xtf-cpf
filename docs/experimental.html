<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html
PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="EN">
  
<head>
  <title>XTF Experimental Features</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link rel="stylesheet" href="library/xtfDocStyle.css" type="text/css" />
</head>

<body bgcolor="#FFFFFF" text="#101010" >

<div class="BaseStyle"> 
  <p class="DocTitle" align="center">XTF Experimental Features</p>
  <p class="Heading1">Table of Contents</p>
  <!-- - - - - - - - - - - - - - --> 
  <ul class="NoBullets">
    <li> <b><a href="#Introduction">Introduction</a></b>     <br/>
      <br/>
    </li>
    <li> <a href="#MoreLikeThis"><b>Similar Documents Query ("more like this")</b></a><br/>
      <ul class="NoBullets">
        <li> <a href="#MoreLike_Algorithm">Similarity Algorithm in Brief</a></li>
        <li> <a href="#MoreLike_Tag">Querying for Similar Documents</a></li>
      </ul>
      <br/>
    </li>
    <li> <a href="#FRBR"><b>Dynamic FRBR</b></a><br/>
      <ul class="NoBullets">
        <li> <a href="#FRBR_Algorithm">FRBRization Algorithm in Brief</a></li>
        <li> <a href="#FRBR_Activation">Activating Dynamic FRBR</a></li>
      </ul>
      <br/>
    </li>
    <li> <a href="#MARC"><b>MARC Record Parsing</b></a><br/>
      <br/>
    </li>
    <li> <a href="#SRU_Servlet"><b>SRU Servlet</b></a><br/>
      <br/>
    </li>
    <li>
      <b><a href="#Boost_Sets">Boost Sets</a></b> 
    </li>
  </ul>
  <p class="Heading1">Introduction<a name="Introduction"></a></p>
  <!-- - - - - - - - - - - - - - --> 
  <p>XTF is in constant development, and from time to time experimental features 
    are added. These features are under evaluation, to see if they're designed 
    well and serve their purpose in the most effective manner possible. Rough 
    documentation is provided here for those curious to play with new and possibly 
    very raw code.</p>
  <p>These features are subject to change, or even to complete removal from XTF. 
    Still, they provide a glimpse into the future of XTF.<br/>
    <br/>
  </p>
  
  <p class="Heading1">Similar Documents Query ("more like this")<a name="MoreLikeThis"></a></p>
  <!-- - - - - - - - - - - - - - --> 
  <p>
    XTF contains an experimental query operator that allows one to query for documents
    that are "similar to" a given target document. This sort of feature is often
    activated in user interfaces using a "More like this..." link.
  </p>
  <p>
    A sample implementation has been provided in the default stylesheets that come
    with XTF. Simply perform a query in <span class="Keyword">crossQuery</span>,
    and click on the "Fetch Similar" link. A similarity query will be executed
    asynchronously, and a summary of the resulting documents inserted directly
    into your search page.
  </p>
  <p>
    The following sections discuss this feature in more depth, starting with a general
    description of the algorithm used, followed by details on how to control
    the query parameters.
  </p>
  <div class="IndentL"> 
    <p class="Heading2">Similarity Algorithm in Brief<a name="MoreLike_Algorithm"></a></p>
    <!-- - - - - - - - - - - - - - --> 
    <p>
    The current algorithm analyzes the content of the bibliographic metadata for 
    the target item, chooses the most important terms in the record, and formulates a new 
    query.  Top-ranking items resulting from the new query are presented as 
    recommendations.
    </p>
    <p>
      While simple in theory, the number of permutations and complications to this approach 
      are vast.  There are many methods for choosing and ordering the top terms, and many 
      approaches to formulating the new query.  Moreover, bibliographic records are 
      inconsistent.  Some records are catalogued exhaustively, others are sparse.  Particularly in 
      sparse records, the choice of a single subject heading can significantly affect the choices 
      and weights of terms.  In extreme cases, this can cause unexpected results:  two 
      versions of a book, sparsely catalogued and with slight differences in subject headings, 
      can yield very different recommendations.  We experimented with various approaches to 
      try to balance these complexities.
    </p>
    <p>
      In our final iteration, each term of each metadata field in the source document is 
      considered in turn. The number of occurrences of that term in the field, <i>tf</i>, is computed. 
      Also, the total number of documents containing that term in that field, <i>df</i>, is fetched from 
      the Lucene index. Terms are filtered out if they occur in too few or too many documents 
      (the limits are adjustable.) Next, a score is calculated for the term by multiplying <i>tf * idf</i>, 
      where <i>idf</i> is the standard log(numDocs / <i>df</i>) + 1. Finally, the score for each term is totaled 
      across all fields it occurs in. The resulting term list is ranked by score and the top-scoring 
      25 terms are chosen (also adjustable.) 
    </p>
    <p>
      The chosen terms are turned into what we call an "Or-Near" query. Each term is searched 
      in each field and document, increasing the score of documents it is found in. Documents 
      with more terms appearing in a single field receive an extra boost. In this way, a score is 
      calculated for each matching document, and the top 5 scoring documents are output as the
      query results.
    </p>
  </div>

  <div class="IndentL"> 
    <!-- - - - - - - - - - - - - - --> 
    <p class="Heading2">Querying for Similar Documents<a name="MoreLike_Tag"></a></p>
    <p>
      To activate the similar documents query, replace your main query output from the
      <b>Query Parser</b> with a <span class="Code">&lt;moreLike></span> tag as specified below.
    </p>
    
    <!-- - - - - - - - - - - - - - --> 
    <!-- MoreLike Tag --> 
    <div class="Sample"> <b><u>Similar Documents Search Tag<a name="crossQuery_QueryParser_Output_MoreLike"></a></u></b><br/>
      <!-- - - - - - - - - - - - - - --> 
      This tag specifies that XTF should locate documents "similar" to a given document,
      where many of the similarity parameters can be controlled. This tag has the form: 
      <br/>
      <br/>
      <div class="IndentLR"> 
        <pre class="Code">&lt;moreLike fields         = "<span class="MacroCode">FieldList</span>"<i></i>
          <i>{</i>boosts        = "<span class="MacroCode">BoostFactorList</span>"<i>}</i>
          <i>{</i>minWordLen    = "<span class="MacroCode">MinWordLength</span>"<i>}</i>
          <i>{</i>maxWordLen    = "<span class="MacroCode">MaxWordLength</span>"<i>}</i>
          <i>{</i>minDocFreq    = "<span class="MacroCode">MinDocFrequency</span>"<i>}</i>
          <i>{</i>maxDocFreq    = "<span class="MacroCode">MaxDocFrequency</span>"<i>}</i>
          <i>{</i>minTermFreq   = "<span class="MacroCode">MinTermFrequency</span>"<i>}</i>
          <i>{</i>termBoost     = "<span class="MacroCode">ShouldBoostTerms</span>"<i>}</i>
          <i>{</i>maxQueryTerms = "<span class="MacroCode">MaxQueryTerms</span>"<i>}</i>&gt;
          
    <span class="MacroCode">DocumentQuery</span>
          
&lt;/moreLike&gt;</pre>
      </div>
      where <br/>
      <div class="IndentLR"> 
        <table cellspacing="12" cellpadding="0">
          <tr> 
            <td width="16%" align="right" valign="top" class="Code"> 
              fields="<span class="MacroCode">FieldList</span>"
            </td>
            <td valign="baseline">
              is a required attribute naming all of the fields that XTF should search for
              "interesting" terms. The field names may be separated by spaces, commas,
              semicolons, or pipe symbols "<span class="Code">|</span>".
              For best performance, this list should be kept
              relatively small, and concentrate on fields of most interest to users,
              such as title, author, subject, etc.
              <p class="Note">Note that XTF currently does <u>not</u>
                support using the special field name
                <span class="Code">text</span> to search the full document text for
                interesting terms, and behavior is undefined if you specify this
                as a field name.
              </p>
            </td>
          </tr>
          <tr> 
            <td width="16%" align="right" valign="top" class="Code"> 
              boosts="<span class="MacroCode">BoostFactorList</span>"
            </td>
            <td valign="baseline">
              is an optional attribute specified exactly one boost factor
              for each field listed in the <span class="Code">fields</span>
              attribute. Each boost factor should be a non-negative
              decimal number, and is multiplied into the scoring for
              all terms from the given field. For example, a boost factor
              of 0.5 will reduce the score for terms by half, while a
              factor of 2.0 will double the score.<br/>
              <p>
                In general, the boost factor is very useful in adjusting the
                weight that various fields have on selecting similar
                documents. For instance, if one decided that the title
                should be twice as important as author and subject, the
                <span class="Code">fields</span> attribute might be 
                "<span class="Code">title,author,subject</span>" and the
                <span class="Code">boosts</span> attribute would be 
                "<span class="Code">2.0,1.0,1.0</span>".
              </p>
              <p>
                If not specified, the boost factor for all fields in the
                <span class="Code">fields</span> list is set to
                <span class="Code">1.0</span>.
              </p>
            </td>
          </tr>
          <tr> 
            <td width="16%" align="right" valign="top" class="Code"> 
              minWordLen="<span class="MacroCode">MinWordLength</span>"
            </td>
            <td valign="baseline">
              is an optional attribute that limits the length of terms from the
              source fields that will be considered for similarity matching.
              Terms shorter than the specified number of characters
              will be disregarded. This can speed up processing and
              improve results by getting rid of useless words.
              If not specified, this attribute defaults to <span class="Code">4</span>.
            </td>
          </tr>
          <tr> 
            <td width="16%" align="right" valign="top" class="Code"> 
              maxWordLen="<span class="MacroCode">MaxWordLength</span>"
            </td>
            <td valign="baseline">
              is an optional attribute that limits the length of terms from the
              source fields will be considered for similarity matching.
              Terms longer than the specified number of characters
              will be disregarded. This can speed up processing and
              improve results by getting rid of useless words.
              If not specified, this attribute defaults to <span class="Code">12</span>.
            </td>
          </tr>
          <tr> 
            <td width="16%" align="right" valign="top" class="Code"> 
              minDocFreq="<span class="MacroCode">MinDocFrequency</span>"
            </td>
            <td valign="baseline">
              is an optional attribute that helps select which terms from source
              fields will be considered for similarity matching. In particular,
              terms that appear in fewer than the specified number of documents
              will be discarded. This can speed processing and improve results
              by discarding highly unusual terms. If not specified, this 
              attribute defaults to <span class="Code">2</span>.
            </td>
          </tr>
          <tr> 
            <td width="16%" align="right" valign="top" class="Code"> 
              maxDocFreq="<span class="MacroCode">MaxDocFrequency</span>"
            </td>
            <td valign="baseline">
              is an optional attribute that helps select which terms from source
              fields will be considered for similarity matching. In particular,
              terms that appear in more than the specified number of documents
              will be discarded. This can speed processing and improve results
              by discarding very common terms. If not specified, this 
              attribute defaults to <span class="Code">-1</span>, meaning
              that there is no limit at all.
            </td>
          </tr>
          <tr> 
            <td width="16%" align="right" valign="top" class="Code"> 
              minTermFreq="<span class="MacroCode">MinTermFrequency</span>"
            </td>
            <td valign="baseline">
              is an optional attribute that helps select which terms from
              source fields will be considered for similarity matching.
              In particular, if the term occurs in the original field
              less than the specified number of times, it will be
              discarded. This can help choose more relevant terms by
              concentrating on those that are repeated in the field.
              If not specified, this attribute defaults to
              <span class="Code">1</span>.
            </td>
          </tr>
          <tr> 
            <td width="16%" align="right" valign="top" class="Code"> 
              termBoost="<span class="MacroCode">ShouldBoostTerms</span>"
            </td>
            <td valign="baseline">
              is an optional attribute controls whether the similarity
              engine should calculate and attach a boost factor to
              each term. This factor will be equal to the score that
              was calculated for that term, and serves to make more
              important terms select documents more specifically. In
              general, it's best to leave this at the default value,
              which is <span class="Code">true</span>.
            </td>
          </tr>
          <tr> 
            <td width="16%" align="right" valign="top" class="Code"> 
              maxQueryTerms="<span class="MacroCode">MaxQueryTerms</span>"
            </td>
            <td valign="baseline">
              is an optional attribute that controls how many
              "interesting" terms are selected from the original
              document's fields. Generally, this should be chosen
              to balance speed (more terms take longer to process)
              vs. quality (more terms can result in higher quality
              results, up to a point.) If not specified, this attribute
              defaults to <span class="Code">10</span>.
            </td>
          </tr>
        </table>
      </div>
      <p>
        Within the moreLike tag, <span class="MacroCode">DocumentQuery</span> is a
        normal XTF query that results in a single document. That document's
        fields will be scanned, and each term will be scored for
        "interestingness" subject to the attributes above. Those terms
        that rank highest will be combined into a new
        OrNear query, and the results will be documents that are
        similar to the original document selected by 
        <span class="MacroCode">DocumentQuery</span>.
      </p>
    </div>
    <br/>
    
  </div>
  
    
  <p class="Heading1">Dynamic FRBR<a name="FRBR"></a></p>
  <!-- - - - - - - - - - - - - - --> 
  <p>
    In a catalog with millions of bibliographic records, the problem of duplicate
    or near-duplicate records often arises. A recognized approach to dealing
    with this problem is to group them together using 
    <a href="http://www.ifla.org/VII/s13/frbr/frbr.htm">Functional Requirements for Bibliographic Records</a> 
    (FRBR).
  </p>
  <p>
    To implement FRBR in XTF, we chose to adapt the standard FRBR
    <a href="http://www.oclc.org/research/software/frbr">Work Set Algorithm</a> to
    our purposes. In particular, we changed the method to dynamically
    determine work groups, rather than making this determination at
    index time. This allowed us to play with and tweak the algorithm
    without having to re-index the entire test collection (over 10 million
    records).
  </p>
  <p>
    For speed, XTF's "dynamic FRBRization" is implemented in Java, and caches
    large tables of data drawn from the underlying Lucene index files.
    In this section we'll cover very briefly the algorithm used, and then
    show how to activate it.
  </p>
  
  <div class="IndentL"> 
    <p class="Heading2">FRBR Algorithm in Brief<a name="FRBR_Algorithm"></a></p>
    <p>
      XTF's dynamic FRBR algorithm takes the entire result set from a query,
      and checks the resulting documents against each other. The goal is to
      group similar records together. For instance, two records with the same
      title and author should end up in the same group.
    </p>
    <p>
      The actual algorithm relies on a score-based approach that allows
      partial matches of various sorts. It is too complex to cover here, 
      so for full details the reader is
      referred to Chapter 5 of the 
      <a href="http://www.cdlib.org/inside/projects/melvyl_recommender/">Melvyl Recommender Project</a>
      <b>Full Text Extension Report</b>. 
    </p>
    <p>
      <span class="Red">Note:</span> The algorithm
      involves loading sizable tables for title, author, date, and ID and caching these
      tables in RAM. This has two major ramifications: first, the tables can take
      some time to load the first time dynamic FRBR is accessed; second, make sure
      to give the servlet container plenty of RAM, especially if the number of
      records in the collection is very large. This can be adjusted by setting
      <span class="Code">-Xmx</span> flag for the Java command that starts the
      servlet container.
    </p>
  </div>

  <div class="IndentL"> 
    <p class="Heading2">Activating Dynamic FRBRization<a name="FRBR_Activation"></a></p>
    <p>
      XTF integrates dynamic FRBRization into the normal crossQuery process by
      exposing the grouped records as a new facet. If you're not familiar
      with facets, refer to the 
      <a href="programming.html#Faceted_Browsing">Faceted Browsing</a> section of the
      <b>XTF Programming Guide</b>.
    </p>
    <p>
      Just like a normal facet, FRBRization is activated by adding a 
      <a href="tagRef.html#crossQuery_QueryParser_Output_Facet">Facet Query Tag</a> to the
      Query Tag produced by your Query Parser stylesheet. However, it
      must be of a special form, as follows.
    </p>
    
    <div class="Sample"> <b><u>Dynamic FRBR Facet Tag<a name="crossQuery_ResultFormatter_FRBRFacet"></a></u></b><br/>
    <!-- - - - - - - - - - - - - - --> 
      <p>
        This tag specifies that the <b>Text Engine</b> should group result
        documents into FRBR Work Sets using the built-in "dynamic FRBRization"
        <a href="#FRBR_Algorithm">algorithm</a>.
        This tag should appear directly within a
        <a href="tagReg.html#crossQuery_QueryParser_Output_Query">Query Tag</a>.
      </p><br/>
      <div class="IndentLR"> 
        <pre class="Code">&lt;facet field="java:org.cdlib.xtf.textEngine.facet.FRBRGroupData
          (<i>{</i><span class="MacroCode">SortOrder</span><i>}</i><span class="MacroCode">FieldList</span>)"
   <span class="MacroCode">... (other attributes as per normal <a href="tagRef.html#crossQuery_QueryParser_Output_Facet">Facet Query Tag</a>) ...</span>
/></pre>
      </div>
      where <br/>
      <div class="IndentLR"> 
        <table cellspacing="12" cellpadding="0">
          <tr> 
            <td width="10%" align="right" valign="top" class="Code"> 
              <span class="MacroCode">SortOrder</span>
            </td>
            <td valign="baseline">
              is an optional field name to sort the resulting groups by. If preceded
              with a hyphen, the sort is reversed. If not specified, the groups
              order will be arbitrary.
            </td>
          </tr>
          <tr> 
            <td width="10%" align="right" valign="top" class="Code"> 
              <span class="MacroCode">FieldList</span>
            </td>
            <td valign="baseline">
              is a required list of the meta-data fields to use to create
              FRBR work groups. The engine looks for fields containing the
              strings "title", "author" or "creator", "date" or "year", and "id"
              to determine how the field contents are to be incorporated into
              the groupings.
            </td>
          </tr>
        </table>
      </div>
      <p>
        The results are identical to a normal facet query except that the
        facet groups are computed dynamically based on the result documents 
        of the query, rather than statically based on values in a particular
        meta-data field.
      </p>
    </div><br/>

  </div>

  <p class="Heading1">MARC Record Parsing<a name="MARC"></a></p>
  <!-- - - - - - - - - - - - - - --> 
  <p>
    California Digital Library (CDL) is experimenting with indexing millions of
    MARC 21 records using XTF. MARC stands for MAchine Readable Cataloging
    and was developed by the <a href="http://www.loc.gov/marc/">Library of Congress</a>,
    Adding MARC support is important for XTF since  many existing library 
    catalogs are available only in MARC format, and XTF can add powerful capabilities (such as
    relevance-based ranking, spelling correction, similarity queries,
    integration with full text data, etc.) to these catalogs.
  </p>
  <p>
    Since MARC records are in a binary (non-XML) format, the 
    <span class="Keyword">textIndexer</span> has the ability to convert
    them to XML, and then send each record to one or more pre-filter
    stylesheets. Support for MARC is potentially very powerful, since
  </p>
  <p>
    One might ask: why not convert all the records to MARCXML once,
    store those XML files in the filesystem, and then index them?
    While this does work, it has proven very slow, and also quite
    wasteful of hard drive space. MARC records on their own are
    very compact, and so great efficiency is gained by converting them
    <i>in memory</i> to MARCXML, and passing that XML directly
    to the pre-filter stylesheets for indexing.
  </p>
  <p>
    To enable this processing, when the <b>Document Selector Stylesheet</b>
    encounters a file containing MARC records, it should output a 
    <a href="tagRef.html#textIndexer_DocSel_Output_File"><span class="Code">&lt;file></span></a> tag with
    the <span class="Code">format</span> attribute set to <span class="Code">'MARC'</span>.
    The <span class="Keyword">textIndexer</span> will recognize this, open the file,
    and convert each record to a separate MARCXML record, and pass each record in
    turn to the pre-filter stylesheets(s). The conversion from MARC to
    MARCXML is performed by the <b>marc4j</b> library, included with the
    XTF distribution.
  </p>
  <p>
    CDL's experience with MARC conversion has been very positive: the conversion
    process is quite fast and the source records remain compact. To deal with
    some data corruption problems, XTF now makes every attempt to
    normalize Unicode characters when possible, and skip invalid characters.
    Also, if an entire record is corrupted, XTF will attempt to re-synchronize
    on the next uncorrupted record. In this way, the system is now
    fairly resilient in the face of minor data corruption.
  </p>
  <p class="Note">
    Note that <span class="Keyword">dynaXML</span> does not handle MARC
    record parsing or display. In CDL's system, <span class="Keyword">crossQuery</span>
    was used to display the records, drawing its data directly from the index.
  </p>
  
  <p class="Heading1">SRU Servlet<a name="SRU_Servlet"></a></p>
  <!-- - - - - - - - - - - - - - --> 
  <p>XTF currently contains an experimental servlet that provides exposes a Zing 
    SRW/SRU interface to an XTF repository. Here's a description taken from the 
    Zing web page (<a href="http://www.loc.gov/standards/sru/">http://www.loc.gov/standards/sru/</a>):</p>
  <div class="Sample">
    <b>Executive Summary: </b>SRW/U is a low-barrier solution to information 
      retrieval. The SRW/U protocol uses easily available technologies -- XML, 
      SOAP, HTTP, URI -- to perform tasks traditionally done using proprietary 
      solutions; it can be carried either via SOAP (SRW) or as a URL (SRU).<br/><br/>
    SRW/U allows users to search remote databases. A user sends a searchRetrieve 
      request which includes a query, and the server responds with a searchRetrieve 
      response indicating the number of records that matched the query, possibly 
      along with some of those records formatted according to an XML schema that 
      the user requested.<br/><br/>
    The query is represented in CQL, the "Common Query Language", designed 
      for human readable, human writable, intuitive queries. It supports very 
      simple queries -- for example an unqualified single term (e.g. "cat") -- 
      but maintains the expressiveness of more complex languages, to represent 
      arbitrarily complex queries.
  </div>
  <p>The idea here is to make an XTF document repository searchable using the 
    SRU protocol (SRU was simpler to implement than SRW.) This will hopefully 
    allow XTF to play well in a larger world of aggregated repositories and meta-searchers.</p>
  <p>
    Current development plans involve folding the SRU servlet into 
    <span class="Keyword">crossQuery</span>,
    once support for CQL has been fully integrated. The stylesheets will then
    recognize SRU queries by their unique URL parameters and redirect to
    special query parsing and formatting.
  </p>
  <p>As with everything else in XTF, SRU support is provided through cooperation 
    between a Java servlet and several XSLT stylesheets. The SRU servlet operation 
    is almost identical to <b><i>crossQuery</i></b>; refer to the diagram below.<br/>
  </p>
  <p align="center"> <img src="art/crossQueryDataFlow.gif" alt="crossQuery Data Flow"/><br/>
    Figure 1: Data Flow in the <b><i>crossQuery</i></b> Servlet </p>
  <p>Here are the important ways that SRU servlet operation differs from crossQuery:</p>
</div>
<ol>
  <li>The incoming query URL should obey SRU specifications, and in particular 
    must specify a query in CQL syntax. Typically the URL will also specify an 
    SRU version and an operation to perform (the default operation is &quot;searchRetrieve&quot;.) 
    Here's a sample URL that talks to the SRU servlet:<br/>
    <br/>
    <div class="Sample"> <span class="Code">http://<span class="MacroCode">yourserver</span>:8080/xtf/SRU?operation=searchRetrieve&amp;query=dc.title=apartheid</span> 
    </div>
    <br/>
    (Of course, you should adjust the port number and server name according to 
    your own installed servlet container.)<br/>
    <br/>
  </li>
  <li>The SRU servlet uses a different set of stylesheets. It has its own <b>Query 
    Parser</b> and <b>Result Formatter</b> stylesheets, located in the <span class="Code">style/SRU</span> 
    subdirectory of the XTF installation. Also, the servlet has its own configuration 
    file, found here: <span class="Code">conf/sru.conf</span><br/>
    <br/>
  </li>
  <li>The input to the SRU <b>Query Parser</b> stylesheet is slightly different. 
    The parameters are all tokenized as normal, but additional parsing is performed 
    on the <span class="Code">query</span> parameter: it is parsed as a CQL query. 
    This results in an XCQL query (that is, XML formatted CQL), and this is added 
    to the <span class="Code">&lt;parameter&gt;</span> block for the <span class="Code">query</span> 
    parameter. The query parser does the work of transforming XCQL to a valid 
    XTF query.<br/>
    <br/>
  </li>
  <li>The output of the SRU <b>Result Formatter</b> stylesheet isn't an HTML web 
    page, but rather an XML search result, obeying the SRW specification for results.</li>
</ol>
<p>Here's some sample output from the SRU servlet:</p>
  <pre class="Sample">
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;srw:searchRetrieveResponse xmlns:srw_dc=&quot;info:srw/schema/1/dc-schema&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema&quot; xmlns:dc=&quot;http://purl.org/dc/elements/1.1/&quot; xmlns:srw=&quot;http://www.loc.gov/zing/srw/&quot;&gt;
   &lt;srw:version&gt;1.1&lt;/srw:version&gt;
   &lt;srw:numberOfRecords&gt;1&lt;/srw:numberOfRecords&gt;
   &lt;srw:records&gt;
      &lt;srw:record&gt;
         &lt;srw:recordPacking&gt;XML&lt;/srw:recordPacking&gt;
         &lt;srw:recordSchema&gt;info:srw/schema/1/dc-v1.1&lt;/srw:recordSchema&gt;
         &lt;srw:recordData&gt;
            &lt;srw_dc:dc xsi:schemaLocation=&quot;info:srw/schema/1/dc-schema http://www.loc.gov/z3950/agency/zing/srw/dc-schema.xsd&quot;&gt;
               &lt;dc:title&gt;The Opening of the Apartheid Mind: Options for the New South Africa&lt;/dc:title&gt;
               &lt;dc:creator&gt;Heribert Adam and Kogila Moodley&lt;/dc:creator&gt;
               &lt;dc:subject&gt;African Studies&lt;/dc:subject&gt;
               &lt;dc:subject&gt;Politics&lt;/dc:subject&gt;
               &lt;dc:subject&gt;African History&lt;/dc:subject&gt;
               &lt;dc:description&gt;Refusing to be governed by what is fashionable or inoffensive, Heribert Adam and Kogila Moodley frankly address the passions and rationalities that drive politics in post-apartheid South Africa...&lt;/dc:description&gt;
               &lt;dc:date&gt;6/28/1993&lt;/dc:date&gt;
               &lt;dc:type&gt;text&lt;/dc:type&gt;
               &lt;dc:identifier&gt;http://ark.cdlib.org/ark:/13030/ft958009mm&lt;/dc:identifier&gt;
               &lt;dc:relation&gt;http://www.ucpress.edu/&lt;/dc:relation&gt;
               &lt;dc:relation&gt;http://escholarship.cdlib.org/&lt;/dc:relation&gt;
               &lt;dc:rights&gt;Public&lt;/dc:rights&gt;
            &lt;/srw_dc:dc&gt;
         &lt;/srw:recordData&gt;
      &lt;/srw:record&gt;
   &lt;/srw:records&gt;
   &lt;srw:echoedSearchRetrieveRequest&gt;
      &lt;srw:version&gt;1.1&lt;/srw:version&gt;
      &lt;srw:query&gt;dc.title=apartheid&lt;/srw:query&gt;
      &lt;srw:startRecord&gt;1&lt;/srw:startRecord&gt;
      &lt;srw:maximumRecords&gt;20&lt;/srw:maximumRecords&gt;
      &lt;srw:recordPacking&gt;xml&lt;/srw:recordPacking&gt;
      &lt;srw:recordSchema&gt;dc&lt;/srw:recordSchema&gt;
   &lt;/srw:echoedSearchRetrieveRequest&gt;
&lt;/srw:searchRetrieveResponse&gt;
</pre>
<p>The servlet query parser knows how to respond to the<span class="Code"> explain 
  </span> and<span class="Code"> searchRetrieve </span><i>operation</i>s. It supports 
  only <i>version</i> 1.1 of the SRU protocol, and requires <i>recordPacking</i> 
  to be<span class="Code"> xml </span>and <i>recordSchema</i> to be<span class="Code"> 
  dc</span> (these are the defaults, so they are optional in the URL.) Other values 
  will produce an appropriate SRU error result.</p>
<p>For further information, you may peruse the stylesheets and the <a href="http://www.loc.gov/standards/sru/">SRW/SRU 
  web page</a>. Comments and improvements are welcome.<br/>
  <br/>
</p>

  <p class="Heading1">Boost Sets<a name="Boost_Sets"></a></p>
<!-- - - - - - - - - - - - - - --> 
<p><b><i>crossQuery </i></b>includes a feature that allows a <b>Boost Set</b> 
  to be specified in the query produced by the <b>Query Parser</b>. This set specifies, 
  for each document, a boost factor to be applied to that document. This allows 
  experimentation with different algorithms that assign a global factor to each 
  document (for instance, Google's PageRank algorithm assigns just such a factor.) 
  A subsequent query could specify a completely different boost set, allowing 
  quick side-by-side testing of various global ranking algorithms.</p>
<p>This feature should be considered very experimental, and may be removed at 
  some future time.</p>
<p>A boost set is specified by a<span class="Code"> boostSet=&quot;<span class="MacroCode">boostFilePath</span>&quot; 
  </span>attribute to the top-level<span class="Code"> &lt;query<span class="MacroCode">...</span>&gt; 
  </span>element produced by the <b>Query Parser</b> stylesheet. The attribute 
  value should specify a path, relative to the XTF base directory, of a boost 
  set file. Additionally you must specify which meta-data field the keys in the 
  given file should match by adding a<span class="Code"> boostSetField=&quot;<span class="MacroCode">fieldName</span>&quot;</span> 
  attribute to the query.</p>
<p>The format of a boost set file is very simple: it should consist of one text 
  line per document, and each line should contain a value from the meta-data field 
  specified by<span class="Code"> boostSetField</span>, followed by a<span class="Code"> 
  | </span> symbol, followed by a factor to be multiplied into the score for that 
  document. For example:</p>
<pre class="Sample">  doc1|1.5
  doc2|2.0
  doc4|0.722</pre>
<p>Boost factors greater that 1.0 will increase the ranking of a document; factors 
  between 0.0 and 1.0 will decrease the ranking of the document; factors less 
  than 0.0 are not valid.</p>
<p>Boost values are multiplied in to the document's basic score calculated by 
  the <b>Text Engine</b>. However, the impact can be subtle. To get a better idea 
  of what is going on, you can turn off <i>score normalization</i> by adding<span class="Code"> 
  normalizeScores=&quot;false&quot; </span>to the query element generated by your 
  <b>Query Parser </b>stylesheet. This will turn off the default behavior which 
  is to scale all the scores so that the top document receives a score of 100.</p>
<p>The lines in the file must be listed in ascending order by value. Each value 
  in the file will be matched to an entry in the index. Any documents not matched 
  in the file are considered to have a boost factor of 1.0 (that is, their scores 
  are unaltered.)</p>
<p>Warnings will be logged if values in the file cannot be matched to index entries, 
  and also if any lines are out of order in the file.</p>
<p>Note that if the boost file is very large, it may take some time to read and 
  process the file the first time it is used, but subsequent accesses will be 
  very fast as the result is cached in memory by the <b><i>crossQuery</i></b> 
  servlet.</p>
</body>

</html>
