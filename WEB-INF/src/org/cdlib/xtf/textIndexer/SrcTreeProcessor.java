package org.cdlib.xtf.textIndexer;

/**
 * Copyright (c) 2004, Regents of the University of California
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions are met:
 *
 * - Redistributions of source code must retain the above copyright notice, 
 *   this list of conditions and the following disclaimer.
 * - Redistributions in binary form must reproduce the above copyright notice, 
 *   this list of conditions and the following disclaimer in the documentation 
 *   and/or other materials provided with the distribution.
 * - Neither the name of the University of California nor the names of its
 *   contributors may be used to endorse or promote products derived from this 
 *   software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
 * POSSIBILITY OF SUCH DAMAGE.
 */

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.regex.Pattern;

import org.cdlib.xtf.util.Trace;

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

/**
 * This class is the main processing shell for files in the source text 
 * tree. It optimizes Lucene database access by opening the index once at
 * the beginning, processing all the source files in the source tree 
 * (including skipping non-source XML files in the tree), and closing the 
 * database at the end. <br><br>
 * 
 * Internally, this class uses the {@link org.cdlib.xtf.textIndexer.XMLTextProcessor}
 * class to actually split the source files up into chunks and add them to the
 * Lucene index.
 * 
 */

public class SrcTreeProcessor

{
  
  private IndexerConfig    cfgInfo;
  private XMLTextProcessor textProcessor;
  private int              nScanned = 0;
  
  ////////////////////////////////////////////////////////////////////////////

  /** Default constructor. <br><br>
   * 
   *  Instantiates the {@link org.cdlib.xtf.textIndexer.XMLTextProcessor} 
   *  used internally to process individual XML source files. <br><br>
   */
  public SrcTreeProcessor()
  
  {
    
    // Instantiate a text processor object to use on each XML file
    // encountered in the file tree.
    //
    textProcessor = new XMLTextProcessor();
  
  } // SrcTreeProcessor()
  
  
  ////////////////////////////////////////////////////////////////////////////

  /** Indexing open function. <br><br>
   * 
   *  Calls the {@link org.cdlib.xtf.textIndexer.XMLTextProcessor} 
   *  {@link org.cdlib.xtf.textIndexer.XMLTextProcessor#open(IndexerConfig) open()}
   *  method to actually create/open the Lucene index.
   * 
   *  @param cfgInfo   The {@link org.cdlib.xtf.textIndexer#IndexerConfig IndexerConfig}
   *                   that indentifies the Lucene index, source text tree, and
   *                   other parameters required to perform indexing. <br><br>
   * 
   *  @throws IOException  Any I/O exceptions generated by the  
   *                       {@link org.cdlib.xtf.textIndexer.XMLTextProcessor} 
   *                       {@link org.cdlib.xtf.textIndexer.XMLTextProcessor#open(IndexerConfig) open()}
   *                       method. <br><br>
   */
  public void open( IndexerConfig cfgInfo ) throws IOException
  {
      
    // Hang on to a reference to the config info.
    this.cfgInfo = cfgInfo;
    
    // Open the Lucene index specified by the config info.
    textProcessor.open( cfgInfo );

    // Give some feedback.
    Trace.info( "Scanning Data Directories..." );
      
  } // open()

  
  ////////////////////////////////////////////////////////////////////////////

  /** Indexing close function. <br><br>
   * 
   *  Calls the {@link org.cdlib.xtf.textIndexer.XMLTextProcessor} 
   *  {@link org.cdlib.xtf.textIndexer.XMLTextProcessor#processQueuedTexts() processQueuedTexts()}
   *  method to flush all the pending Lucene writes to disk. Then it calls the 
   *  {@link org.cdlib.xtf.textIndexer.XMLTextProcessor} 
   *  {@link org.cdlib.xtf.textIndexer.XMLTextProcessor#close() close()} 
   *  method to actually close the Lucene index. <br><br>
   * 
   *  @throws IOException  Any I/O exceptions generated by the 
   *                       {@link org.cdlib.xtf.textIndexer.XMLTextProcessor} 
   *                       {@link org.cdlib.xtf.textIndexer.XMLTextProcessor#close() close()}
   *                       method. <br><br>
   *
   */
  
  public void close() throws IOException
  
  {
      // Done scanning now.
      Trace.more( " Done." );

      // Flush the remaining open documents.    
      textProcessor.processQueuedTexts();
      
      // Let go of the config info now that we're done with it.
      cfgInfo = null;

      // Close the index database.
      textProcessor.close();
      
  } // close()

  
  ////////////////////////////////////////////////////////////////////////////

  /** Process a directory containing source XML files. <br><br>
   * 
   * This method iterates through a source directory's contents indexing any
   * valid files it finds, any processing any sub-directories. <br><br>
   * 
   * @param currFile   The current file to be processed. This may be a source
   *                   XML file, a file to be skipped, or a subdirectory. <br><br>
   * 
   *  @throws   Exception  Any exceptions generated internally
   *                       by the <code>File</code> class or the  
   *                       {@link org.cdlib.xtf.textIndexer.XMLTextProcessor} 
   *                       class. <br><br>
   * 
   */
  public void processDir( File currFile ) throws Exception
  
  { 
    
    // If we weren't passed a directory, process as a regular file.
    if( !currFile.getCanonicalFile().isDirectory() ) {
        processFile( currFile );
        return;
    }
    
    // We're looking at a directory. Get the list of files it contains.
    String[] fileStrs = currFile.getCanonicalFile().list();
    ArrayList list = new ArrayList( fileStrs.length );
    for( int i = 0; i < fileStrs.length; i++ )
        list.add( fileStrs[i] );
    Collections.sort( list );

    // Process all of the non-directory files first.
    boolean anyProcessed = false;
    for( Iterator i = list.iterator(); i.hasNext(); ) {
        File subFile = new File( currFile, (String) i.next() );
        if( !subFile.getCanonicalFile().isDirectory() ) {
            if( processFile(subFile) )
                anyProcessed = true;
        }
    }

    // If we found any files to process, the convention is that subdirectories
    // contain file related to the ones we processed, and that they shouldn't
    // be processed individually.
    //
    if( anyProcessed )
        return;
    
    // Didn't find any files to process. Try sub-directories.
    for( Iterator i = list.iterator(); i.hasNext(); ) {
        File subFile = new File( currFile, (String) i.next() );
        if( subFile.getCanonicalFile().isDirectory() )
            processDir( subFile );
    }

  } // processDir()
  
  
  ////////////////////////////////////////////////////////////////////////////

  /** Process file. <br><br>
   * 
   * This method processes a source file, including source text XML files, and 
   * files to be ignored. <br><br>
   * 
   * @param fileToProcess  The current file to be processed. This may be a 
   *                       source XML file or a file to be skipped. <br><br>
   * 
   * @return               true if the document was processed, false if it was
   *                       skipped due to skipping rules.<br><br>
   * 
   *  @throws   Exception   Any exceptions generated internally by the <code>File</code>
   *                        class or the {@link org.cdlib.xtf.textIndexer.XMLTextProcessor} 
   *                        class. <br><br>
   * 
   * 
   *  @.warnings  This method only accepts actual file names. Do not pass 
   *              a directory name to this method. <br><br>
   * 
   */
  public boolean processFile( File fileToProcess ) throws Exception 
  
  {
    // If this file is not an XML file, skip it.
    if( !fileToProcess.toString().endsWith(".xml") ) return false;
    
    // Get the Path string for the file.
    String path = fileToProcess.getCanonicalPath();
    
    // If the file matches a skip specification, skip it.
    Pattern[] skipFiles = cfgInfo.indexInfo.skipFiles;
    
    if( skipFiles != null ) {
      
        for( int i = 0; i < skipFiles.length; i++ ) {
            
            if( skipFiles[i].matcher(path).matches() ) return false;
        
        } // for( int i = 0; i < skipFiles.length; i++ )
    
    } // if( skipFiles != null )
    
    // Print out dots as we process large amounts of files, just so the
    // user knows something is happening.
    //
    if( ((nScanned++) % 200) == 0 )
        Trace.more( "." );

    // Call the XML text file processor to do the work.    
    textProcessor.queueText( fileToProcess );
    
    // Let the caller know we didn't skip the file.
    return true;
        
  } // processFile()
  
} // class SrcTreeProcessor
